### 实时场景深度与环境建模详解（Environment Depth → TSDF 体素 → GPU 射线）

本文梳理项目中“实时环境深度扫描、体素建模与命中查询”的完整链路，涵盖深度采集、法线生成、体素集成与射线查询，指向具体代码位置并解释实现逻辑。

---

## 概览
- **深度输入**：从设备/平台侧获取环境深度纹理与 ZBuffer 参数（Meta Environment Depth），并在每帧写入全局 Shader 属性。
- **法线生成**：通过 ComputeShader 将深度转换为世界坐标并计算法线，生成 2DArray 法线贴图，供后续体素集成参考表面方向。
- **体素建模（TSDF）**：以 `metersPerVoxel` 为分辨率构建 3D 体素体（`RenderTexture` 3D），对深度视锥采样点进行体素融合（Signed Distance），并过滤玩家体素以避免自体干扰。
- **查询（GPU Raycast）**：对 3D 体素体进行 GPU 射线步进/收缩迭代，返回最近命中距离，供游戏逻辑（如子弹命中）使用。

---

## 深度采集与全局参数（DepthKitDriver）

职责：从平台侧获取环境深度贴图及相关参数，计算投影视图矩阵（含左右眼），并写入全局 Shader 变量，向下游 ComputeShader 提供统一访问入口。

```1:116:Assets/Anaglyph/XRTemplate/Depth/DepthKitDriver.cs
public static readonly int Meta_EnvironmentDepthTexture_ID = ID("_EnvironmentDepthTexture");
...
public static bool DepthAvailable { get; private set; }
...
Texture depthTex = Shader.GetGlobalTexture(Meta_EnvironmentDepthTexture_ID);
DepthAvailable = depthTex != null;
...
Shader.SetGlobalTexture(agDepthTex_ID, depthTex);
Shader.SetGlobalTexture(agDepthEdgeTex_ID, Shader.GetGlobalTexture(Meta_PreprocessedEnvironmentDepthTexture_ID));
Shader.SetGlobalVector(agDepthZParams_ID, Shader.GetGlobalVector(Meta_EnvironmentDepthZBufferParams_ID));
...
// 计算并写入左右眼投影/视图矩阵与逆矩阵
Shader.SetGlobalMatrixArray(nameof(agDepthProj), agDepthProj);
Shader.SetGlobalMatrixArray(nameof(agDepthProjInv), agDepthProjInv);
Shader.SetGlobalMatrixArray(nameof(agDepthView), agDepthView);
Shader.SetGlobalMatrixArray(nameof(agDepthViewInv), agDepthViewInv);
```

要点：
- `DepthAvailable` 控制深度可用性；后续模块可据此选择回退逻辑。
- `agDepth*` 全局变量为后续 HLSL/Compute 访问的统一接口（纹理、法线、大小、矩阵）。

---

## 深度法线贴图生成（DepthNorm.compute）

职责：通过相邻像素的世界坐标差分计算法线，写入 `agDepthNormalTexRW`（二维数组，双眼）。

```1:36:Assets/Anaglyph/XRTemplate/Depth/DepthNorm.compute
[numthreads(8, 8, 1)]
void DepthNorm(uint3 id : SV_DispatchThreadID)
{
    float2 texSizeF = agDepthTexSize;
    uint2 ind = id.xy; float2 uv = id.xy / texSizeF; uint eye = id.z;
    float3 depthWorld = agDepthNDCtoWorld(float3(uv, agDepthTex[uint3(ind, eye)]), eye);
    ...
    float3 depthWorldH = agDepthNDCtoWorld(...);
    float3 depthWorldV = agDepthNDCtoWorld(...);
    const float3 hDeriv = depthWorldH - depthWorld;
    const float3 vDeriv = depthWorldV - depthWorld;
    float3 worldNorm = -normalize(cross(hDeriv, vDeriv));
    agDepthNormalTexRW[id] = float4(worldNorm, 1);
}
```

要点：
- 通过 `agDepthNDCtoWorld` 将深度从 NDC 转回世界坐标，随眼索引进行分层处理。
- 生成的法线纹理被写入全局 `agDepthNormalTex`，供体素集成时进行表面一致性筛选。

---

## 体素集成与射线查询（EnvironmentMapper + EnvironmentMapping.compute）

### 体素体与采样视锥初始化

```1:76:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
clearKernel = new(shader, "Clear");
integrateKernel = new(shader, "Integrate");
raycastKernel = new(shader, "Raycast");
shader.SetInts("volumeSize", vWidth, vHeight, vDepth);
shader.SetFloat(nameof(metersPerVoxel), metersPerVoxel);
Clear();
ScanLoop();
```

```134:175:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
var depthProj = Shader.GetGlobalMatrixArray(DepthKitDriver.agDepthProj_ID)[0];
FrustumPlanes frustum = depthProj.decomposeProjection;
frustum.zFar = maxEyeDist; // 限制最远深度
List<Vector3> positions = new(200000);
...
for (float z = f.zNear; z < f.zFar; z += metersPerVoxel) { ... add voxel centers within frustum ... }
frustumVolume = new ComputeBuffer(positions.Count, sizeof(float) * 3);
integrateKernel.Set(nameof(frustumVolume), frustumVolume);
```

说明：
- 以 `metersPerVoxel` 为步长在深度视锥内采样，构建 3D 网格采样点，写入 `frustumVolume` 供 Integrate 内核并行处理。
- 体素体由 3D `RenderTexture` 承载（项目资源 `Environment Volume.renderTexture`）。

```1:41:Assets/Anaglyph/XRTemplate/Depth/Environment Volume.renderTexture
m_Dimension: 3
m_Width: 1024, m_Height: 128, m_VolumeDepth: 1024
m_EnableRandomWrite: 1
```

### 实时集成循环

```90:108:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
private async void ScanLoop()
{
    while (enabled)
    {
        await Awaitable.WaitForSecondsAsync(1f / dispatchesPerSecond);
        var depthTex = Shader.GetGlobalTexture(depthTexID);
        if (depthTex == null) continue;
        var normTex = Shader.GetGlobalTexture(normTexID);
        if (frustumVolume == null) Setup();
        Matrix4x4 view = Shader.GetGlobalMatrixArray(viewID)[0];
        Matrix4x4 proj = Shader.GetGlobalMatrixArray(projID)[0];
        ApplyScan(depthTex, normTex, view, proj);
    }
}
```

```111:132:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
public void ApplyScan(Texture depthTex, Texture normTex, Matrix4x4 view, Matrix4x4 proj)
{
    shader.SetMatrixArray(viewID, new[]{ view, Matrix4x4.zero });
    shader.SetMatrixArray(projID, new[]{ proj, Matrix4x4.zero });
    shader.SetMatrixArray(viewInvID, new[] { view.inverse, Matrix4x4.zero });
    shader.SetMatrixArray(projInvID, new[] { proj.inverse, Matrix4x4.zero });
    // 屏蔽玩家体素（避免自体干扰）
    shader.SetInt(numPlayersID, PlayerHeads.Count);
    shader.SetVectorArray(playerHeadsWorldID, headPositions);
    integrateKernel.Set(depthTexID, depthTex);
    integrateKernel.Set(normTexID, normTex);
    integrateKernel.DispatchGroups(frustumVolume.count, 1, 1);
}
```

### TSDF 集成逻辑（ComputeShader）

```1:106:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapping.compute
RWTexture3D<half> volume; // tsdf
StructuredBuffer<float3> frustumVolume;
...
[numthreads(64, 1, 1)]
void Integrate (uint i : SV_DispatchThreadID)
{
    float3 vLocalPos = frustumVolume[i];
    float3 vWorldPos = mul(agDepthViewInv[0], float4(vLocalPos, 1));
    uint3 id = worldToVoxel(vWorldPos);
    float3 eyePos = agDepthEyePos();
    float3 voxPos = voxelToWorld(id);
    float4 voxHCS = agDepthWorldToHCS(voxPos);
    float3 voxNDC = agDepthHCStoNDC(voxHCS);
    float depth = agDepthSample(voxNDC.xy);
    float3 depthPos = agDepthNDCtoWorld(float3(voxNDC.xy, depth));
    float voxEyeDist = distance(voxPos, eyePos);
    float depthEyeDist = distance(depthPos, eyePos);
    float3 depthNorm = agDepthNormalSample(voxNDC.xy);
    float sDist = depthEyeDist - voxEyeDist; // 正：体素在表面之前；负：越过表面
    float normDot = -dot(normalize(voxPos - eyePos), depthNorm);
    sDist *= saturate(normDot); // 借助法线筛选背面、噪声
    half sDistNorm = sDist / metersPerVoxel; sDistNorm = min(sDistNorm, 1);
    // 排除玩家体素（头顶/脚底/半径范围）
    bool inPlayer = false; ... if (inPlayer) { /*skip*/ }
    if (sDistNorm > -1 && !inPlayer && normDot > MIN_DOT)
        volume[id] = sDistNorm;
}
```

说明：
- 体素以 Signed Distance 形式存储（近似 TSDF）：正值表示体素位于表面前方，接近 0 表示接近表面。
- 通过世界法线一致性 `normDot` 抑制异常和背面采样，避免噪声写入。
- 自身玩家体素通过头部位置数组进行几何剔除，避免近身误判。

### GPU 射线（Raycast）

```198:259:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
public static bool Raycast(Ray ray, float maxDist, out RayResult result, bool fallback = false)
    => Instance.RaycastInternal(ray, maxDist, out result, fallback);
...
raycastKernel.DispatchGroups(totalNumSteps, 1, 1);
resultBuffer.GetData(d);
if (hitDistInt >= lengthInt) return false;
result = new(ray.GetPoint(hitDist), hitDist); result.didHit = true;
```

```107:144:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapping.compute
uniform float3 rcOrig; uniform float3 rcDir; uniform float rcIntScale;
RWStructuredBuffer<uint> rcResult; Texture3D<half> rcVolume;
// 线程内 mini raymarch：逐步靠近 0 等值面
for (int i = 0; i < 3; i++)
{
    float3 uvw = worldToVoxelUVW(worldPos);
    half signedDistance = sampleDist(uvw);
    worldPos += rcDir * signedDistance;
}
if (abs(signedDistance) < 0.02f)
    InterlockedMin(rcResult[0], distFromCenterInt);
```

说明：
- 将每个线程的起点沿射线按体素间距平移，执行数次“位移 = 签名距离”的 SDF 迭代，接近等值面（0）后记录最短命中距离。
- 结果通过 `InterlockedMin` 并行写最短距离；CPU 侧读回一个整型距离值并换算为米。
- 当深度不可用时（如 `DepthAvailable == false` 且 `fallback == true`），退化为“地面交点”近似：

```201:219:Assets/Anaglyph/XRTemplate/Depth/EnvironmentMapper.cs
if (!DepthKitDriver.DepthAvailable && fallback)
{
    // 与 y=0 地面近似相交
    Vector2 slope = new Vector2(dir.x, dir.z) / dir.y;
    result.point = new Vector3(slope.x * -orig.y + orig.x, 0, slope.y * -orig.y + orig.z);
    result.distance = Vector3.Distance(orig, result.point);
    return true;
}
```

---

## 与游戏逻辑集成（示例）

- 子弹命中环境距离预估：

```58:66:Assets/Anaglyph/LaserTag/Weapons/Bullets/Bullet.cs
fireRay = new(transform.position, transform.forward);
if (EnvironmentMapper.Raycast(fireRay, MaxTravelDist, out var envCast))
    if (IsOwner) envHitDist = envCast.distance; else EnvironmentRaycastRpc(envCast.distance);
```

- 独立测试脚本：

```11:16:Assets/Anaglyph/LaserTag/Tools/DepthRaycastTest.cs
Ray ray = new Ray(transform.position, transform.forward);
hitIndicator.gameObject.SetActive(EnvironmentMapper.Raycast(ray, 50f, out var result));
hitIndicator.position = result.point;
```

---

## 关键参数与资源

- 分辨率与频率：

```55:61:Assets/Anaglyph/LaserTag/Systems.prefab
metersPerVoxel: 0.1
dispatchesPerSecond: 10
maxEyeDist: 7
minEyeDist: 1
```

- 体素体资源：

```1:40:Assets/Anaglyph/XRTemplate/Depth/Environment Volume.renderTexture
Dimension: 3, Size: 1024x128x1024, RandomWrite: Enabled
```

- 玩家剔除源：

```8:16:Assets/Anaglyph/XRTemplate/Depth/EnvIgnorePlayer.cs
EnvironmentMapper.Instance.PlayerHeads.Add(transform);
...
EnvironmentMapper.Instance.PlayerHeads.Remove(transform);
```

---

## 小结
- 项目通过 `DepthKitDriver` 持续读取设备环境深度与参数，生成法线贴图；
- `EnvironmentMapper` 构建视锥采样点并以 ComputeShader 将深度融合至 3D 体素体（近似 TSDF）；
- 依赖 GPU Raycast 在体素体上进行快速碰撞/命中查询；
- 提供回退机制与玩家剔除，保证在无深度或近身场景中的稳定性；
- 该管线在局域网联机中完全本地执行，不占用网络带宽，命中结果通过 RPC 广播以统一表现。


