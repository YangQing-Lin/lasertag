### 项目概览

本仓库是一个基于 Unity 的多人激光对战（LaserTag）示例项目，围绕 XR（主要是 Meta/Quest 设备）、Unity Netcode for GameObjects、多种共位（Colocation）方案（Meta 空间锚、AprilTag）以及环境深度（Environment Depth）构建。代码按功能拆分为若干模块，每个模块通过 `asmdef` 明确边界，便于在大型工程中复用与裁剪。

本文档按模块介绍功能定位、核心类与关键实现方式，并用简短流程描述典型数据/逻辑流。

---

## 模块总览

- Anaglyph（基础与调试）
- VariableObjects（可序列化变量/选项系统）
- Netcode（联网封装与对象池）
- LaserTag（核心玩法：玩家、武器、子弹、基地/据点、对局裁判）
- XRTemplate（XR 框架、环境深度、设备相机、共位系统）
- DriftCorrection（环境点云/ICP 漂移校正原型）
- Menu（内置 UI 导航与菜单定位）
- Input（输入广播）
- Files（简单持久化）
- InGameConsole（内置日志面板）
- Helpers / Drawing / MeshScripts / GPU（辅助工具与渲染脚手架）

---

## Anaglyph（基础与调试）
路径：`Assets/Anaglyph/`

- 功能定位：工程级基础设施与调试开关。
- 关键类：
  - `Anaglyph.Anaglyph`：全局 DebugMode（运行时根据 `Debug.isDebugBuild` 设置）；提供 `DebugModeChanged` 事件。
  - `ActivateIfDebug` / `RenderIfDebug` / `DestroyIfNotEditor` / `Helpers/DebugBuildCheck`：根据 Debug 模式或是否在编辑器中运行启用/禁用对象或渲染。
  - `InGameConsole.InGameConsole`：捕获 `Application.logMessageReceived`，在 UI 文本显示日志，可切换是否展开堆栈。
  - `Drawing/ProceduralDrawFeature`：URP 渲染特性，暴露 `Draw` 事件以在 RenderGraph 中注入自定义绘制。

实现要点：
- 全局调试状态通过事件驱动各组件的可见性/开启状态（低耦合）。
- 控制台以最大字符数裁剪历史，避免 UI 文本过长带来的性能问题。

---

## VariableObjects（可序列化变量/选项）
路径：`Assets/Anaglyph/VariableObjects/`

- 功能定位：ScriptableObject 驱动的运行时配置与可订阅变量（支持持久化）。
- 关键类：
  - `GenericVariableObject<T>`：泛型变量基类，持有默认值与当前值，提供 `beforeChange/onChange` 事件。
  - `BoolObject` / `FloatObject` / `ColorObject`：具体类型的变量，`Bool/Float` 支持 `PlayerPrefs` 持久化。
  - `GenericVariableObjectEvents<T>`：将变量变化转为 UnityEvent，便于在场景中串接逻辑。

实现要点：
- 通过 ScriptableObject 实例在场景与代码之间传递状态，减少直接引用与硬编码。
- 支持持久化的变量在 `OnEnable` 时自动从 `PlayerPrefs` 读取并监听保存。

---

## Netcode（联网封装与对象池）
路径：`Assets/Anaglyph/Netcode/`

- 功能定位：统一的联网生命周期封装与 NetworkObject 对象池。
- 关键类：
  - `NetcodeHelper`：
    - 管理网络状态（Disconnected/Connecting/Connected）、冷却时间、连接事件。
    - 支持两种协议：
      - LAN：`UnityTransport` + 本地 IP。
      - UnityService：`DistributedAuthorityTransport` + `Unity Services` `Multiplayer` 会话（`CreateOrJoinSessionAsync`）。
    - 负责匿名登录、会话创建/加入、断线清理。
  - `NetworkPose`：可网络序列化的 `(position, rotation)` 结构体，用于同步姿态。
  - `NetworkObjectPool`：
    - 预热、获取、归还 `NetworkObject`，并注册为 Netcode 的 Prefab Handler，实现 Spawn/Destroy 与池管理对接。
  - `ActiveIfConnected` / `InteractiveIfConnected` / `DontRenderIfOwner`：根据连接/所有权调整对象激活、UI 交互、渲染。

实现要点：
- 使用 `NetworkManager.OnConnectionEvent` 管理 UI 和系统状态。
- 对象池通过 `INetworkPrefabInstanceHandler` 与 Netcode 生命周期打通，减少运行时 Instantiate/Destroy 开销。

---

## LaserTag（核心玩法）
路径：`Assets/Anaglyph/LaserTag/`

### 玩家与队伍
- `Player/MainPlayer`
  - 本地玩家控制器：生命值、死亡/复活计时、在友方基地判定、事件分发（`Died/Respawned/Damaged/TeamChanged`）。
  - 连接成功后 `SpawnAvatar()` 生成并绑定 `Networking.Avatar`（玩家网络体）。
  - 负责将本地 `Head/Left/Right` 变换写入网络体的对应骨骼，用于他人观察同步。
  - 伤害与死亡：当 `Health` 降到 0，设置 `WeaponsManagement.canFire=false`，标记死亡并开始复活计时，到时调用 `Respawn()` 重置状态。
- `Networking/Avatar`
  - 继承 `NetworkBehaviour`，持有 `isAliveSync`、`scoreSync`、`TeamOwner`。
  - 维护全局玩家表 `AllPlayers` 与 `OtherPlayers`，并在受击、被击杀等事件中通过 RPC 通知（例如 `KilledByPlayerRpc` 触发加分）。
- `Player/Teams/TeamOwner`
  - `NetworkVariable<byte> teamSync` 持有队伍号，变更时发 `OnTeamChange` 事件。
- `Player/Teams/Teams`
  - 定义队伍数量、颜色与名称映射；用于 UI/特效着色等。
- `Geo`
  - 提供几何判定，如“点是否在圆柱范围内”，供基地/据点判定使用。

### 规则与对局
- `Gamemodes/MatchReferee`
  - 裁判与状态机：`NotPlaying → Mustering → Countdown → Playing`。
  - `MatchSettings` 控制是否分队、是否在基地复活、复活时长、回血速率、计分规则（击杀得分、控点每秒得分）、胜利条件（计时/达分）。
  - Owner 端驱动对局：集结（所有玩家进入任一基地）→ 倒计时 → 开始；按 `timer` 或 `score target` 结束。
  - 通过 `ScoreTeamRpc`、`ResetScoresRpc` 同步积分与结束条件。
- `Gamemodes/ScoreCounter`
  - 简易记分板：每队一个 `NetworkVariable<int>`，支持达分触发 `OnTeamWin`。

### 场景目标与计分
- `Objects/Gameplay/Base`
  - 基地对象（半径常量，维护 `AllBases` 列表）。玩家头部在圆柱范围内即判定“在基地”。
- `Objects/Gameplay/ControlPoint`
  - 占点玩法：
    - `HoldingTeam`（控点队伍）、`CapturingTeam`（当前占领者）、`millisCaptured`（占领进度）。
    - `Update()` 中 Owner 负责：检测控制区内玩家，若仅有单方队伍则推进占领进度，进度满调用 `CaptureOwnerRpc` 切换控点；
      对局进行时每秒为 `HoldingTeam` 加分（由 `MatchReferee` 执行）。

### 武器与子弹
- `Weapons/WeaponsManagement`：全局“能否开火”开关（死亡/复活控制）。
- `Weapons/Blaster`、`Weapons/Automatic`、`Weapons/Wand`
  - 基于输入或“甩腕”检测触发 `Fire()`，使用 `NetworkObjectPool` 生成弹丸（bolt prefab），并以 `LocalClientId` 作为所有者进行 Spawn。
  - `Wand` 通过 OVR 提供的左右手 `Node` 采样短时间角速度，阈值触发“甩腕开火”。
- `Weapons/Bullets/Bullet`
  - Owner 侧进行弹道推进：以初始位置和方向构造光线，时间/速度换算出位移；
  - 使用 `XRTemplate.EnvironmentMapper.Raycast` 进行“环境深度”命中检测，取最近环境命中距离；
  - `Physics.Linecast` 检测物理命中（玩家碰撞体），若命中玩家则按距离曲线计算伤害并 `DamageRpc`；
  - 命中（环境或物理）后通过 `HitRpc` 广播最终命中点与法线，停止飞行并在 Owner 端延迟 `despawnDelay` 回收网络对象。
- `Weapons/Bullets/BulletVisuals`
  - 监听 `Bullet.OnFire/OnCollide`，按队伍颜色设置 VFX、Trail 与“深度光”（`DepthLightDriver`）。

---

## XRTemplate（XR 框架、环境深度、共位）
路径：`Assets/Anaglyph/XRTemplate/`

### XR Rig 与输入
- `MainXRRig`
  - 提供静态访问 `Camera`、`TrackingSpace`，并提供将 Rig 匹配到目标 `Pose` 的工具函数（含“保持向上/扁平化 Up”选项）。
- `HandedHierarchy`
  - 表示该层级代表的左右手，向子对象暴露 `InteractorHandedness` 与对应 `XRNode`。

### 环境深度（Environment Depth）
- `Depth/DepthKitDriver`
  - 从 Meta 全局 Shader 参数读取环境深度与 ZBuffer 参数，计算并设置给自有的 `agDepth*` 全局参数（视图/投影矩阵、法线纹理）。
  - 通过 ComputeShader 生成法线贴图（2DArray），供其他模块使用。
- `Depth/EnvironmentMapper`
  - 将环境深度体素化到 `RenderTexture volume`，异步循环集成。
  - 提供 `Raycast(ray, maxDist, out result, fallback)`：在 Compute 上计算与体素体的相交，必要时可回退为“落地线相交”。
  - 被 `Bullet` 用于环境命中距离计算。

### 设备相机与 AprilTag 追踪
- `DeviceCameras/CameraReader`
  - Android 侧 Java 接口读取相机帧（灰度），暴露纹理、时间戳与相机内外参；管理权限与打开/关闭生命周期。
- `AprilTags/AprilTagTracker`
  - 从 `CameraReader` 获取帧，计算 FOV，调用原生 TagDetector 检测，结合头显位姿换算至世界坐标后回调 `OnDetectTags`。

### 共位（Colocation）
- 接口与管理：
  - `SharedSpaces/Colocation`：`IColocator` 接口 + `Colocation.SetActiveColocator()`。
  - `LaserTag/ColocationManager`（网络脚本）：在网络 Spawn 后根据 `BoolObject useAprilTagColocation` 选择 `MetaAnchorColocator` 或 `AprilTagColocator`，并下发 AprilTag 尺寸。
- Meta 空间锚：
  - `SharedSpaces/MetaAnchors/MetaAnchorColocator`：如无锚则在头前方生成网络锚体 `ColocationAnchor`（内含 `NetworkedAnchor`），当 `IsAnchored` 后用 `MainXRRig.MatchPoseToTarget` 将 Rig 对齐到期望位姿。
  - `SharedSpaces/MetaAnchors/NetworkedAnchor`：包装 `OVRSpatialAnchor`，网络同步原始姿态与 UUID，负责加载/本地化。
- AprilTag 共位：
  - `SharedSpaces/AprilTags/AprilTagColocator`：收集本地检测到的标签与“规范位置”（由 Owner 通过 RPC 注册/同步），根据头部移动阈值与锁定距离做插值对齐。

---

## DriftCorrection（漂移校正原型）
路径：`Assets/Anaglyph/DriftCorrection/`

- 功能定位：点云最近邻与 ICP 拟合原型，用于将深度点云与环境模型对齐，示例/研究性质。
- 关键类：
  - `PointTree`：基于 KD 树（递归划分轴）结构与 Job/Burst 的并行最近邻搜索；`BuildJob` 构建树，`FindClosestPoints` 查询最近点。
  - `IterativeClosestPoint`：
    - `Iterate(subject, subjTrans, targetTree, knnResults)`：并行找最近邻，随后 `FitCorresponding` 计算变换；
    - `FitCorresponding`：计算质心、协方差，SVD 求旋转，结合质心得到平移，最终输出 `float4x4.TRS` 矩阵。
  - `EnvironmentDriftCorrection`：示例组件，构建环境点树，对测试网格迭代拟合并更新其 Transform。

---

## Menu（UI 导航与菜单定位）
路径：`Assets/Anaglyph/Menu/`

- `MenuPositioner`：监听 XR 控制器菜单键，若菜单不在视野内则重定位到相机前方偏移；控制显示时禁用/隐藏一组组件/对象。
- 页面导航：
  - `Pages/NavPagesParent`：维护页面历史与过渡动画（曲线 + 时长），支持后退；
  - `Pages/NavPage` / `Pages/NavButton`：页面/按钮组件，通过父容器完成切页；
  - `SingleActiveChild`：启动时仅激活一个子节点，并注入“点击则关闭同级”的行为。

---

## Input（输入广播）
路径：`Assets/Anaglyph/Input/`

- `InputBroadcaster`：持有 `InputActionMap`，将 `action.started/performed/canceled` 统一通过 `BroadcastMessage(action.name, context)` 向同物体广播。
- 用法：只要在组件上实现与 InputAction 同名的方法签名，即可收到输入回调，减少显式引用与耦合。

---

## Files（轻量持久化）
路径：`Assets/Anaglyph/Files/`

- `GameSave`：`JsonUtility` + `Application.persistentDataPath` 的简易读写封装，针对结构体数据。

---

## 其他辅助模块

- `Helpers`：主要为 `DebugBuildCheck`，用于启动时广播是否为 Debug 构建。
- `Drawing`：自定义 URP 渲染入口（见上）。
- `MeshScripts/MeshScript`：拷贝并修改 Mesh 的基类（用于编辑器/运行时网格变形原型）。
- `GPU` / `StrikerSupport`：当前工程中作为占位/扩展点使用，未见核心逻辑依赖。

---

## 关键数据流与交互

### 1) 联网与对象池
- 进入游戏 → `NetcodeHelper.Host/ConnectLAN/ConnectUnityServices` → 设置 Transport/会话 → `NetworkManager` 驱动连接事件。
- 客户端连接成功 → `MainPlayer` 监听连接事件 → `SpawnAvatar()` → 生成 `Networking.Avatar`（玩家网络体）。
- `NetworkObjectPool` 在会话开始时注册/预热 Prefab，弹丸/特效等通过池获取与回收。

### 2) 开火与命中
- 输入/甩腕满足条件 → 武器 `Fire()`：从池中取出弹丸 NetworkObject 并以本地客户端为所有者 Spawn。
- `Bullet`（Owner）逐帧推进：
  - 计算沿射线的位移与环境命中距离（`EnvironmentMapper.Raycast`）。
  - 若与玩家碰撞体 `Linecast` 命中：`DamageRpc(damage, ownerId)`；若先与环境命中：`HitRpc` 广播停靠点。
  - 命中后在 Owner 延迟回收。

### 3) 据点与加分
- `ControlPoint` 在 `Update`：Owner 统计圈内玩家，推进或回退占领进度。
- 完成占领 → 切换 `HoldingTeam`；对局进行中每秒 `ScoreTeamRpc(holdingTeam, perSecondPoints)`。

### 4) 对局流程
- Owner 端 `MatchReferee.StartMatchRpc(settings)` → `Mustering`（全部玩家站入任一基地）→ `Countdown(3s)` → `Playing`。
- 胜利条件：计时结束或任一队达到目标分 → `MatchFinishedRpc()`。

### 5) 共位
- 网络 Spawn → `ColocationManager` 选择 `MetaAnchor` 或 `AprilTag`：
  - Meta：生成/绑定网络锚，锚定后 `MainXRRig.MatchPoseToTarget` 对齐到期望位姿；
  - AprilTag：检测/注册规范标签位置，按头部运动约束与插值对齐场景坐标系。

---

## 扩展与注意事项（建议）

- 命中判定一致性：当前由 Owner 进行子弹推进与命中判断，网络抖动可能影响体验。可引入服务器裁决或延迟补偿策略。
- 作弊防护：客户端持有所有权的射击与击中报告需要配合服务器验证（例如最大射速、最大距离、角速度阈值等）。
- 资源注册：确保 `NetworkObjectPool.PooledPrefabsList` 包含需要的网络 Prefab（子弹、锚点等），并在会话开始时注册成功。
- AprilTag 共位：对标签的“规范位置”维护须谨慎，建议提供清理/重置流程，防止历史数据造成错误对齐。
- 环境深度可用性：`DepthKitDriver.DepthAvailable` 为假时 `EnvironmentMapper.Raycast` 可回退用“地面线交”，注意落地高度/相机姿态设置。

---

## 参考入口（重要脚本）

- 玩家/对局：`LaserTag/Player/MainPlayer.cs`、`LaserTag/Player/Avatar.cs`、`LaserTag/Gamemodes/MatchReferee.cs`
- 武器/子弹：`LaserTag/Weapons/*`、`LaserTag/Weapons/Bullets/Bullet.cs`、`LaserTag/Weapons/Bullets/BulletVisuals.cs`
- 场景目标：`LaserTag/Objects/Gameplay/Base.cs`、`LaserTag/Objects/Gameplay/ControlPoint.cs`
- 联网封装：`Netcode/NetcodeHelper.cs`、`Netcode/NetworkObjectPool.cs`
- XR/共位：`XRTemplate/MainXRRig.cs`、`XRTemplate/SharedSpaces/*`、`LaserTag/ColocationManager.cs`
- 环境深度：`XRTemplate/Depth/*`、`XRTemplate/Camera/CameraReader.cs`
- 配置变量：`VariableObjects/*`
- 菜单/输入：`Menu/*`、`Input/InputBroadcaster.cs`


